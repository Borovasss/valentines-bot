import asyncio
import sqlite3
import logging
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram import F
from aiogram.types import LabeledPrice
import uuid

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Initialize bot
bot = Bot(token="7953383202:AAGDM20U_YXOj_t_PfNvScytpFl55pRc_lE")  # –ë–æ—Ç –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
dp = Dispatcher()

# Initialize SQLite database
def init_db():
    try:
        conn = sqlite3.connect("valentines.db")
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            unique_link TEXT UNIQUE
        )''')
        c.execute('''CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            receiver_id INTEGER,
            sender_id INTEGER,
            message TEXT,
            is_anonymous INTEGER DEFAULT 1
        )''')
        conn.commit()
        logging.info("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")
    finally:
        conn.close()

# Generate unique link for user
async def generate_unique_link(user_id):
    try:
        unique_id = str(uuid.uuid4())
        conn = sqlite3.connect("valentines.db")
        c = conn.cursor()
        c.execute("INSERT OR REPLACE INTO users (user_id, unique_link) VALUES (?, ?)", (user_id, unique_id))
        conn.commit()
        logging.info(f"–°–æ—Ö—Ä–∞–Ω—ë–Ω user_id {user_id} —Å unique_id {unique_id} –≤ –ë–î")
        bot_info = await bot.get_me()
        link = f"https://t.me/{bot_info.username}?start={unique_id}"
        logging.info(f"–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ —Å—Å—ã–ª–∫–∞ –¥–ª—è user_id {user_id}: {link}")
        return link
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Å—ã–ª–∫–∏ –¥–ª—è user_id {user_id}: {e}")
        return None
    finally:
        conn.close()

# Get user_id from unique link
def get_user_from_link(unique_id):
    try:
        conn = sqlite3.connect("valentines.db")
        c = conn.cursor()
        c.execute("SELECT user_id FROM users WHERE unique_link = ?", (unique_id,))
        result = c.fetchone()
        logging.info(f"–ü–æ–∏—Å–∫ user_id –¥–ª—è unique_id {unique_id}: {result}")
        return result[0] if result else None
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ user_id –¥–ª—è unique_id {unique_id}: {e}")
        return None
    finally:
        conn.close()

# Start command handler
@dp.message(Command("start"))
async def start_command(message: types.Message):
    args = message.text.split()
    logging.info(f"–ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /start –æ—Ç user_id {message.from_user.id} —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏: {args}")
    
    # Moderator start command
    if message.from_user.id == 5397929249:  # –í–∞—à Telegram ID
        await message.answer("–°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω! –ë–æ—Ç –≥–æ—Ç–æ–≤ –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è.")
        logging.info("–ë–æ—Ç: –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω")
        return
    
    # Regular user start command
    if len(args) > 1:
        unique_id = args[1]
        receiver_id = get_user_from_link(unique_id)
        if receiver_id and receiver_id != message.from_user.id:
            await message.answer("üíå –ù–∞–ø–∏—à–∏—Ç–µ –∞–Ω–æ–Ω–∏–º–Ω–æ–µ –≤–∞–ª–µ–Ω—Ç–∏–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:", reply_markup=types.ReplyKeyboardRemove())
            dp.data[message.from_user.id] = {"receiver_id": receiver_id}
            logging.info(f"–£—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞ —Å—Å—ã–ª–∫–∞ –¥–ª—è user_id {message.from_user.id}, receiver_id: {receiver_id}")
        else:
            await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–≤–æ—é —Å—Å—ã–ª–∫—É.")
            logging.warning(f"–ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞ –¥–ª—è user_id {message.from_user.id}, unique_id: {unique_id}")
    else:
        user_link = await generate_unique_link(message.from_user.id)
        if user_link:
            share_button = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üì§ –ü–æ–¥–µ–ª–∏—Ç—å—Å—è —Å—Å—ã–ª–∫–æ–π", switch_inline_query=user_link)]
            ])
            await message.answer(
                f"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –∞–Ω–æ–Ω–∏–º–Ω—ã—Ö –≤–∞–ª–µ–Ω—Ç–∏–Ω–æ–∫! üíñ\n"
                f"–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —ç—Ç–æ–π —Å—Å—ã–ª–∫–æ–π, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å –∞–Ω–æ–Ω–∏–º–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è:\n{user_link}\n\n"
                f"–ö–æ–≥–¥–∞ –≤–∞–º –æ—Ç–ø—Ä–∞–≤—è—Ç –≤–∞–ª–µ–Ω—Ç–∏–Ω–∫—É, –≤—ã —Å–º–æ–∂–µ—Ç–µ –∑–∞ 5 Telegram Stars —É–∑–Ω–∞—Ç—å, –∫—Ç–æ –µ—ë –Ω–∞–ø–∏—Å–∞–ª!",
                reply_markup=share_button
            )
            logging.info(f"–°—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ user_id {message.from_user.id}: {user_link}")
        else:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Å—ã–ª–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
            logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É –¥–ª—è user_id {message.from_user.id}")

# Messages command handler (for moderator)
@dp.message(Command("messages"))
async def messages_command(message: types.Message):
    if message.from_user.id != 5397929249:  # –¢–æ–ª—å–∫–æ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
        await message.answer("‚ùå –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
        logging.warning(f"–ù–µ–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ /messages –æ—Ç user_id {message.from_user.id}")
        return
    
    try:
        conn = sqlite3.connect("valentines.db")
        c = conn.cursor()
        c.execute("SELECT id, receiver_id, sender_id, message, is_anonymous FROM messages ORDER BY id DESC LIMIT 10")
        messages = c.fetchall()
        conn.close()

        if not messages:
            await message.answer("–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.")
            logging.info("–ö–æ–º–∞–Ω–¥–∞ /messages: –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø—É—Å—Ç–∞")
            return

        response = "–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è:\n\n"
        for msg in messages:
            msg_id, receiver_id, sender_id, text, is_anonymous = msg
            response += (
                f"ID: {msg_id}\n"
                f"–û—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å ID: {sender_id}\n"
                f"–ü–æ–ª—É—á–∞—Ç–µ–ª—å ID: {receiver_id}\n"
                f"–¢–µ–∫—Å—Ç: {text}\n"
                f"–ê–Ω–æ–Ω–∏–º–Ω–æ: {'–î–∞' if is_anonymous else '–ù–µ—Ç'}\n\n"
            )
        await message.answer(response)
        logging.info(f"–ö–æ–º–∞–Ω–¥–∞ /messages –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ –¥–ª—è user_id {message.from_user.id}")
    except Exception as e:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π.")
        logging.error(f"–û—à–∏–±–∫–∞ –∫–æ–º–∞–Ω–¥—ã /messages: {e}")

# Support commands
@dp.message(Command("paysupport"))
async def paysupport_command(message: types.Message):
    await message.answer("–î–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ –æ–ø–ª–∞—Ç–µ –ø–∏—à–∏—Ç–µ: @Borov3223")  # –ó–∞–º–µ–Ω–∏—Ç–µ, –µ—Å–ª–∏ –¥—Ä—É–≥–æ–π –∞–∫–∫–∞—É–Ω—Ç

@dp.message(Command("support"))
async def support_command(message: types.Message):
    await message.answer("–î–ª—è –æ–±—â–∏—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–∏—à–∏—Ç–µ: @Borov3223")  # –ó–∞–º–µ–Ω–∏—Ç–µ, –µ—Å–ª–∏ –¥—Ä—É–≥–æ–π –∞–∫–∫–∞—É–Ω—Ç

@dp.message(Command("terms"))
async def terms_command(message: types.Message):
    await message.answer("–£—Å–ª–æ–≤–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è: https://telegram.org/tos")

# Handle incoming text messages
@dp.message(F.text)
async def handle_message(message: types.Message):
    logging.info(f"–ü–æ–ª—É—á–µ–Ω–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç user_id {message.from_user.id}: {message.text}")
    if message.from_user.id in dp.data:
        receiver_id = dp.data[message.from_user.id]["receiver_id"]
        sender_id = message.from_user.id
        message_text = message.text
        logging.info(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è: sender_id {sender_id}, receiver_id {receiver_id}, —Ç–µ–∫—Å—Ç: {message_text}")

        # Save message to database
        try:
            conn = sqlite3.connect("valentines.db")
            c = conn.cursor()
            c.execute("INSERT INTO messages (receiver_id, sender_id, message) VALUES (?, ?, ?)",
                      (receiver_id, sender_id, message_text))
            conn.commit()
            message_id = c.lastrowid
            logging.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –ë–î: message_id {message_id}, receiver_id {receiver_id}, sender_id {sender_id}")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –ë–î: {e}")
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
            return
        finally:
            conn.close()

        # Send message to moderator
        mod_message = (
            f"–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:\n"
            f"–û—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å ID: {sender_id}\n"
            f"–ü–æ–ª—É—á–∞—Ç–µ–ª—å ID: {receiver_id}\n"
            f"–¢–µ–∫—Å—Ç: {message_text}"
        )
        try:
            await bot.send_message(
                chat_id=5397929249,  # –í–∞—à Telegram ID
                text=mod_message
            )
            logging.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—É: {mod_message}")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—É: {e}")

        # Notify receiver
        try:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üîç –£–∑–Ω–∞—Ç—å –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è (5 Stars)", callback_data=f"reveal_{message_id}")]
            ])
            await bot.send_message(
                receiver_id,
                f"üíå –í—ã –ø–æ–ª—É—á–∏–ª–∏ –∞–Ω–æ–Ω–∏–º–Ω—É—é –≤–∞–ª–µ–Ω—Ç–∏–Ω–∫—É:\n{message_text}",
                reply_markup=keyboard
            )
            logging.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—É—á–∞—Ç–µ–ª—é receiver_id {receiver_id}")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—É—á–∞—Ç–µ–ª—é receiver_id {receiver_id}: {e}")
        await message.answer("–í–∞—à–µ –≤–∞–ª–µ–Ω—Ç–∏–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ! üíñ")
        del dp.data[message.from_user.id]
    else:
        await message.answer(
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–≤–æ—é —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ, –∏–ª–∏ /start, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–≤–æ—é —Å—Å—ã–ª–∫—É."
        )

# Handle reveal sender button
@dp.callback_query(F.data.startswith("reveal_"))
async def reveal_sender(callback: types.CallbackQuery):
    message_id = int(callback.data.split("_")[1])
    conn = sqlite3.connect("valentines.db")
    c = conn.cursor()
    c.execute("SELECT sender_id FROM messages WHERE id = ?", (message_id,))
    result = c.fetchone()
    sender_id = result[0] if result else None
    conn.close()

    if sender_id:
        prices = [LabeledPrice(label="–£–∑–Ω–∞—Ç—å –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è", amount=500)]
        await bot.send_invoice(
            chat_id=callback.from_user.id,
            title="–£–∑–Ω–∞—Ç—å –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è",
            description="–ó–∞–ø–ª–∞—Ç–∏—Ç–µ 5 Telegram Stars, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è.",
            payload=f"reveal_{message_id}",
            provider_token="",
            currency="XTR",
            prices=prices
        )
    else:
        await callback.message.answer("‚ùå –û—à–∏–±–∫–∞: —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        logging.error(f"–°–æ–æ–±—â–µ–Ω–∏–µ —Å ID {message_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –¥–ª—è reveal")

# Handle pre-checkout query
@dp.pre_checkout_query()
async def process_pre_checkout_query(pre_checkout_query: types.PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)

# Handle successful payment
@dp.message(F.successful_payment)
async def successful_payment(message: types.Message):
    payload = message.successful_payment.invoice_payload
    message_id = int(payload.split("_")[1])
    conn = sqlite3.connect("valentines.db")
    c = conn.cursor()
    c.execute("SELECT sender_id FROM messages WHERE id = ?", (message_id,))
    result = c.fetchone()
    sender_id = result[0] if result else None
    c.execute("UPDATE messages SET is_anonymous = 0 WHERE id = ?", (message_id,))
    conn.commit()
    conn.close()

    if sender_id:
        sender_chat = await bot.get_chat(sender_id)
        sender_profile = f"https://t.me/{sender_chat.username or sender_id}"
        await message.answer(f"–û—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å —Ä–∞—Å–∫—Ä—ã—Ç! –ü—Ä–æ—Ñ–∏–ª—å: {sender_profile}")
    else:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        logging.error(f"–û—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –¥–ª—è message_id {message_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")

async def main():
    init_db()
    try:
        await dp.start_polling(bot)
        logging.info("–û–ø—Ä–æ—Å —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –æ–ø—Ä–æ—Å–∞: {e}")
        raise  # –ü–æ–≤—Ç–æ—Ä–Ω–æ –≤—ã–±—Ä–æ—Å–∏—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –ª–æ–≥–∞—Ö Render

if __name__ == "__main__":
    asyncio.run(main())
